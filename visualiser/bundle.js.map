{"version":3,"sources":["webpack:///webpack/bootstrap c1ddaf2a0ae9873aac7d","webpack:///./src/controller.js","webpack:///./src/lineage.js","webpack:///./src/lifelines.js"],"names":[],"mappings":"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","file":"bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap c1ddaf2a0ae9873aac7d\n **/","import * as lineageModule from 'lineage';\n//import Reign from 'lineage';\n//import Lineage from 'lineage';\nimport * as lifelinesModule from 'lifelines';\n\nfunction processTopOfStack(branchingStack, depths, outputSet, link2person) {\n\tvar topOfStack = branchingStack.pop();\n\tvar currPersonLink = topOfStack[0];\n\tvar addedAsChild = topOfStack[1];\n\n\tvar currPerson = link2person[currPersonLink];\n\t\n\toutputSet.add(currPerson.link);\n\n\tvar parentLinks = new Set(currPerson.getParents().map(function(x) {return x.link}));\n\tvar childLinks = new Set(currPerson.getChildren().map(function(x) {return x.link}));\n\t\t\n\tif (depths[currPerson.link] > 0) {\n\t\tvar relativeDepth = depths[currPerson.link] - 1;\n\t\tvar relatives = currPerson.getRelatives();\n\t\tif (addedAsChild) {\n\t\t\t// Only consider the parents if this person was added for\n\t\t\t// expansion as a child:\n\t\t\trelatives = currPerson.getParents();\n\t\t}\n\t\t\n\t\tvar nRelatives = relatives.length;\n\t\tfor (var relativeIdx = 0; relativeIdx < nRelatives; relativeIdx++) {\n\t\t\tvar relative = relatives[relativeIdx];\n\n\t\t\tif (!(outputSet.has(relative.link))) {\n\t\t\t\t// Relative has not yet been explored:\n\t\t\t\tif (!(relative.link in branchingStack)) {\n\t\t\t\t\tif (parentLinks.has(relative.link)) {\n\t\t\t\t\t\tbranchingStack.push([relative.link, false]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbranchingStack.push([relative.link, true]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ((!(relative.link in depths)) || (depths[relative.link] < relativeDepth)) {\n\t\t\t\t\tdepths[relative.link] = relativeDepth;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Relative has been explored but may still need further\n\t\t\t\t// exploration depending on depth:\n\t\t\t\tif (depths[relative.link] < relativeDepth) {\n\t\t\t\t\tdepths[relative.link] = relativeDepth;\n\t\t\t\t\tif (!(relative.link in branchingStack)) {\n\t\t\t\t\t\tif (parentLinks.has(relative.link)) {\n\t\t\t\t\t\t\tbranchingStack.push([relative.link, false]);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tbranchingStack.push([relative.link, true]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nfunction expandIndividuals(seedPeople, depth, link2person) {\n\t// Perform expansion in parents and children by the specified distance...\n\tvar nPeople = seedPeople.length;\n\t\n\t// Maintain a dictionary indicating depth for each person:\n\tvar personLink2depth = {};\n\tfor (var personIdx = 0; personIdx < nPeople; personIdx++) {\n\t\tvar currPerson = seedPeople[personIdx];\n\t\tpersonLink2depth[currPerson.link] = depth;\n\t}\n\n\t// Implementing a refined approach for branching: The behaviour will\n\t// differ when branching from a child node, compared to other nodes\n\t// (starting node or parent node).\n\n\t// Also maintain a stack of people left to branch from:\n\tvar branchingStack = seedPeople.map(function(person) {return [person.link, false]});\n\n\t// Also maintain a set of people to output:\n\tvar outputSet = new Set();\n\n\twhile (branchingStack.length > 0) {\n\t\tprocessTopOfStack(branchingStack, personLink2depth, outputSet, link2person);\n\t}\n\t\n\treturn outputSet;\n}\n\n\nfunction updateLifelinePlot(targetSVG, personName2link, lineageName2link, link2person, link2lineage) {\n\t// User can select a set of lineages of interest and a set of additional individuals of interest.\n\t// XXX NEXT: Implement extractParamsFromInterface() and then test it + get it working here:\n\t//var params = extractParamsFromInterface();\n\t//var specifiedPeople = params[0];\n\t//var specifiedLineages = params[1];\n\t\n\t// TEST: REMOVE THESE TWO LINES ONCE PARAMETER EXTRACTION ABOVE IS WORKING:\n\tvar specifiedLineages = [link2lineage[\"/wiki/List_of_Swedish_monarchs\"]];// Swedish, /wiki/Holy_Roman_Emperor ;//];// link2lineage[\"/wiki/List_of_Swedish_monarchs\"]\n\tvar specifiedPeople = [link2person[\"/wiki/Gustavus_Adolphus_of_Sweden\"], link2person[\"/wiki/Louis_XIV_of_France\"]];// [link2person[\"/wiki/Frederick_I_of_Sweden\"], link2person[\"/wiki/Frederick_V,_Elector_Palatine\"]];//  /wiki/John_III_of_Sweden /wiki/Henry_VIII_of_England\n\n\tvar peopleInLineages = [];\n\tif (specifiedLineages.length > 0) {\n\t\tvar peopleArrs = specifiedLineages.map(function (lineage) {return lineage.getPeople()});\n\t\tvar peopleInLineages = Array.from(new Set(peopleArrs.reduce(function (list1, list2, currentIndex, array) {return list1.concat(list2)})));\n\t}\n\tvar seedIndividuals = new Set(peopleInLineages.concat(specifiedPeople));\n\n\t//console.log(\"SEED:\");\n\t//console.log(seedIndividuals);\n\t\n\t// Retrieve the current depth setting from the interface:\n\t// XXX\n\n\tvar depth = 1;\n\n\tvar expandedIndividuals = expandIndividuals(Array.from(seedIndividuals), depth, link2person);\n\t//console.log(\"UPDATED:\");\n\t//console.log(expandedIndividuals);\n\n\t// Clear the svg element, as it must be blank prior to generating a new\n\t// lifeline plot using it:\n\tclearSVG(targetSVG);\n\n\tvar newPlot = new lifelinesModule.LifelinePlot(targetSVG, expandedIndividuals, specifiedLineages, link2person);\n\tnewPlot.displayLifelines();\n}\n\n\nfunction clearSVG(svg) {\n\twhile (svg[0][0].lastChild) {\n\t    svg[0][0].removeChild(svg[0][0].lastChild);\n\t}\n}\n\n\n// NOTE: This function might introduce performance problems; need to test.\n// Also, could be refactored.\nfunction hydratePersonData(jsonObj) {\n\tvar link2person = {};\n\tvar links = Object.keys(jsonObj)\n\tvar nLinks = links.length;\n\tfor (var linkIdx = 0; linkIdx < nLinks; linkIdx++) {\n\t\tcurrLink = links[linkIdx];\n\t\tcurrVals = jsonObj[currLink];\n\t\tvar currPerson = new lineageModule.Person(currLink, currVals['name'], currVals['birth'], currVals['death'])\n\t\tlink2person[currLink] = currPerson;\n\t}\n\n\t// Keep track of all lineages:\n\tvar link2lineage = {};\n\n\t// Need to make a second pass over the person objects to generate links:\n\tlinks = Object.keys(link2person);\n\tfor (var personIdx = 0; personIdx < nLinks; personIdx++) {\n\t\tvar currLink = links[personIdx];\n\t\tvar currPerson = link2person[currLink];\n\t\tvar currVals = jsonObj[currLink];\n\t\tvar mother = link2person[currVals['mother']];\n\t\tcurrPerson.setMother(mother);\n\t\tvar father = link2person[currVals['father']];\n\t\tcurrPerson.setFather(father);\n\t\tvar childLinks = currVals['children']\n\t\tvar nChildLinks = childLinks.length;\n\t\tfor (var childIdx = 0; childIdx < nChildLinks; childIdx++) {\n\t\t\tvar currChildLink = childLinks[childIdx];\n\t\t\tvar currChild = link2person[currChildLink];\n\t\t\tcurrPerson.addChild(currChild);\n\t\t}\n\n\t\tvar reignInfo = currVals['reigns'];\n\t\tvar reignLinks = Object.keys(reignInfo);\n\n\t\tvar nReigns = reignLinks.length;\n\t\tfor (var reignIdx = 0; reignIdx < nReigns; reignIdx++) {\n\t\t\tvar currReignLink = reignLinks[reignIdx];\n\n\t\t\tvar currLineage = null;\n\t\t\tif (!(currReignLink in link2lineage)) {\n\t\t\t\tlink2lineage[currReignLink] = new lineageModule.Lineage(currReignLink);\n\t\t\t}\n\n\t\t\tcurrLineage = link2lineage[currReignLink];\n\t\t\t\n\t\t\t// Generate a new Reign object linking to the above lineage:\n\t\t\tvar currReign = new lineageModule.Reign(currLineage, reignInfo[currReignLink][0], reignInfo[currReignLink][1], currPerson);\n\t\t\tcurrLineage.addReign(currReign);\n\t\t\t\n\t\t\tcurrPerson.addReign(currReign);\n\t\t}\n\t}\n\n\treturn [link2person, link2lineage];\n}\n\n\n// Load the JSON data specifying the nobility data:\nd3.json(\"Test.json\", function(error, jsonObj) {\n\tif (error) throw error;\n\t//console.log(jsonObj)\n\n\t// Extract names of people from the input:\n\t// FIXME: Add actual code for doing this here; get the names from the hydrated objects:\n\tvar names = Object.keys(jsonObj).map(function(obj) {return obj.split(\"/\")[2]})\n\t\n\t// Hydrate the data, retrieving a dictionary of link2person and link2lineage:\n\tvar hydratedData = hydratePersonData(jsonObj);\n\tvar link2person = hydratedData[0];\n\tvar link2lineage = hydratedData[1];\n\n\t//console.log(link2person);\n\t//console.log(link2lineage);\n\n\tvar personName2link = lifelinesModule.getPersonName2Link(link2person);\n\tvar lineageName2link = lifelinesModule.getLineageName2Link(link2lineage);\n\n\tlifelinesModule.populateInterface(Object.keys(personName2link), Object.keys(lineageName2link));\n\n\t//console.log(personName2link);\n\t//console.log(lineageName2link)\n\n\t// Retrieve the svg target element from the webpage:\n\tvar svgTarget = d3.select(\"#lifelinePlotSvg\");\n\t\n\tupdateLifelinePlot(svgTarget, personName2link, lineageName2link, link2person, link2lineage);\n\t//interface.onClick = updateLifelinePlot(personName2link, lineageName2link, link2person, link2lineage);\n});\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/controller.js\n **/","// Person class:\nexport class Person {\n\tconstructor(link, name, birth, death) {\n\t\tthis.link = link;\n\t\tthis.name = name;\n\t\tthis.birth = birth;\n\t\tthis.death = death;\n\t\tthis.mother = null;\n\t\tthis.father = null;\n\t\tthis.children = [];\n\t\tthis.reigns = [];\n\t}\n\n\tsetMother(mother) {\n\t\tthis.mother = mother;\n\t}\n\t\n\tsetFather(father) {\n\t\tthis.father = father;\n\t}\n\n\taddChild(child) {\n\t\tthis.children.push(child);\n\t}\n\t\n\taddReign(reign) {\n\t\tthis.reigns.push(reign);\n\t}\n\t\n\tgetRelatives() {\n\t\tvar relatives = [];\n\t\tif(!(typeof this.mother === 'undefined')){\n\t    \trelatives.push(this.mother);\n\t\t};\n\t\tif(!(typeof this.father === 'undefined')){\n\t    \trelatives.push(this.father);\n\t\t};\n\t\treturn relatives.concat(this.children);\n\t}\n\n\tgetParents() {\n\t\tvar parents = [];\n\t\tif(!(typeof this.mother === 'undefined')){\n\t    \tparents.push(this.mother);\n\t\t};\n\t\tif(!(typeof this.father === 'undefined')){\n\t    \tparents.push(this.father);\n\t\t};\n\t\treturn parents;\n\t}\n\n\tgetChildren() {\n\t\treturn this.children;\n\t}\n\n\tgetDeath() {\n\t\tif (this.death === null) {\n\t\t\tvar today = new Date();\n\t\t\treturn today.getFullYear();\n\t\t} else {\n\t\t\treturn this.death;\n\t\t}\n\t}\n}\n\n\n// FIXME/NOTE:\n// I have selectedPeople and link2person appearing all over the place\n// together. This is because the items in selectedPeople apparently\n// need to be strings, due to javascript. Perhaps I should have\n// some object that encapsulates a set of people, keeping this detail\n// internal. Won't implement this yet though.\n\n\nexport function getFirstBirth(selectedPeople, link2person) {\n\tvar peopleArr = Array.from(selectedPeople);\n\tvar earliestBirthDate = Infinity;\n\tvar nPeople = peopleArr.length;\n\n\tfor (var personIdx = 0; personIdx < nPeople; personIdx++) {\n\t\tvar currPersonObj = link2person[peopleArr[personIdx]];\n\t\tif (currPersonObj.birth < earliestBirthDate) {\n\t\t\tearliestBirthDate = currPersonObj.birth;\n\t\t}\n\t}\n\t\n\treturn earliestBirthDate;\n}\n\n\nexport function getEndDeath(selectedPeople, link2person) {\n\tvar peopleArr = Array.from(selectedPeople);\n\tvar lastDeathDate = -Infinity;\n\tvar nPeople = peopleArr.length;\n\tfor (var personIdx = 0; personIdx < nPeople; personIdx++) {\n\t\tvar currPersonObj = link2person[peopleArr[personIdx]];\n\t\tif (currPersonObj.death > lastDeathDate) {\n\t\t\tlastDeathDate = currPersonObj.death;\n\t\t}\n\t\t\n\t\t// If no death is given, then the person is assumed to still\n\t\t// be alive => return the current year:\n\t\tif (currPersonObj.death === null) {\n\t\t\tvar today = new Date();\n\t\t\tlastDeathDate = today.getFullYear();\n\t\t}\n\t}\n\t\n\treturn lastDeathDate;\n}\n\n\n// Reign class:\nexport class Reign {\n\tconstructor(lineage, start, end, person) {\n\t\tthis.lineage = lineage;\n\t\tthis.start = start;\n\t\tthis.end = end;\n\t\tthis.person = person;\n\t}\n}\n\n\n// Lineage class:\nexport class Lineage {\n\tconstructor(link) {\n\tthis.link = link;\n\tthis.name = link; // FIXME: Edit this once lineage name information is available.\n\tthis.reigns = [];\n\t}\n\n\taddReign(reign) {\n\t\tthis.reigns.push(reign);\n\t}\n\t\n\tgetPeople() {\n\t\tvar people = new Set();\n\t\tvar reigns = this.reigns;\n\t\tvar nReigns = reigns.length;\n\t\tfor (var reignIdx = 0; reignIdx < nReigns; reignIdx++) {\n\t\t\tvar currReign = reigns[reignIdx];\n\t\t\tpeople.add(currReign.person);\n\t\t}\n\t\t\n\t\treturn Array.from(people);\n\t}\n}\n\n\n/** WEBPACK FOOTER **\n ** ./src/lineage.js\n **/","import * as lineageModule from 'lineage';\n\nfunction compareBirth(lifeline1, lifeline2) {\n\t// Compare the two lifeline objects by birth date:\n\treturn lifeline1.person.birth - lifeline2.person.birth;\n}\n\n\n// NOTE/FIXME: I think I can do better than this, to achieve more compressed results:\nfunction detectClusters(lifelinesByBirth) {\n\t// Input must be lifelines sorted by birth date.\n\t\n\tvar outputClusters = [];\n\tvar prevDeath = -Infinity;\n\tvar currCluster = [];\n\t\n\tfor (var lifelineIdx = 0; lifelineIdx < lifelinesByBirth.length; lifelineIdx++) {\n\t\tvar currLifeline = lifelinesByBirth[lifelineIdx];\n\t\tif (currLifeline.person.birth > prevDeath) {\n\t\t\t// This is a new cluster...\n\n\t\t\tif (currCluster.length > 0) {\n\t\t\t\t// There was a preceding cluster => Add it to the output\n\t\t\t\t// clusters:\n\t\t\t\toutputClusters.push(currCluster);\n\t\t\t}\n\t\t\t\n\t\t\t// Start out this new cluster:\n\t\t\tcurrCluster = [];\n\t\t}\n\t\t\n\t\t// Add the current lifeline to this cluster:\n\t\tcurrCluster.push(currLifeline);\n\t\t\n\t\t// Update the end death date for this cluster:\n\t\tvar currPersonDeath = currLifeline.person.getDeath();\n\t\tprevDeath = currPersonDeath;\n\t}\n\t\n\t// Add the final cluster to the output and return them all:\n\toutputClusters.push(currCluster);\n\treturn outputClusters;\n}\n\n\nfunction adjustGridPositions(cluster, leftEnd, rightEnd) {\n\t// Adjust the grid positions of the specified lifelines, to span the given\n\t// position range relative to the starting grid position for each lifeline\n\t// in the cluster, which should be the same to start with.\n\t\n\t// XXX CONTINUE HERE: INVESTIGATE ALTERNATIVE ALGORITHMS + DEBUGGING\n\t// VISUALISATION.\n\t\n\tvar numLifelines = cluster.length;\n\tvar numPositionsIncludingEnds = numLifelines + 2;\n\tvar incrementSize = (rightEnd-leftEnd) / (numPositionsIncludingEnds-1);\n\tfor (var lifelineIdx = 0; lifelineIdx < numLifelines; lifelineIdx++) {\n\t\tvar currLifeline = cluster[lifelineIdx];\n\n\t\tvar currAdjustment = leftEnd + (incrementSize * (lifelineIdx+1));\n\t\t\n\t\t// Update position for the current lifeline:\n\t\tcurrLifeline.gridPosition = currLifeline.gridPosition + currAdjustment;\n\t}\n}\n\n\n// A component of a lifeline plot, consisting of a set of interconnected\n// lifeline bars:\nexport class LifelinePlotComponent {\n\tconstructor(peopleLinks, hostPlot) {\n\t\tthis.peopleLinks = peopleLinks;\n\t\tthis.hostPlot = hostPlot;\n\n\t\t// FIXME: Not sure about this: I believe I am duplicating data here, as I\n\t\t// have a link to the person objects directly, and also via their lifeline\n\t\t// objects:\n\t\tthis.link2lifeline = {};\n\t}\n\n\t// Generates a Lifeline object for each person. Also, generates relevant\n\t// parent-child links, as Birthline objects:\n\tgenerateLifelines() {\n\t\tfor (var personIdx = 0; personIdx < this.peopleLinks.length; personIdx++) {\n\t\t\tvar currPersonLink = this.peopleLinks[personIdx];\n\t\t\tvar currPerson = this.hostPlot.link2person[currPersonLink];\n\n\t\t\tvar currLifeline = new Lifeline(currPerson, this);\n\t\t\tthis.link2lifeline[currPersonLink] = currLifeline;\n\t\t}\n\t}\n\n\t// Generates Birthline objects for all Lifeline objects:\n\tgenerateBirthlines() {\n\t\tfor (var link in this.link2lifeline) {\n\t\t\tvar currLifeline = this.link2lifeline[link];\n\n\t\t\t// Make mother and father links if those individuals\n\t\t\t// are amongst the people to be plotted:\n\t\t\tvar mother = currLifeline.person.mother;\n\t\t\tvar father = currLifeline.person.father;\n\n\t\t\tif (mother !== undefined && this.hostPlot.peopleToPlot.has(mother.link)) {\n\t\t\t\tvar motherLifeline = this.link2lifeline[mother.link];\n\t\t\t\tcurrLifeline.motherBirthline = new Birthline(currLifeline, motherLifeline);\n\t\t\t}\n\n\t\t\tif (father !== undefined && this.hostPlot.peopleToPlot.has(father.link)) {\n\t\t\t\tvar fatherLifeline = this.link2lifeline[father.link];\n\t\t\t\tcurrLifeline.fatherBirthline = new Birthline(currLifeline, fatherLifeline);\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// Adjust the x position of every lifeline in this component, adding\n\t// the specified amount...\n\tadjustOverallPosition(adjustment) {\n\t\tfor (var link in this.link2lifeline) {\n\t\t\tvar currLifeline = this.link2lifeline[link];\n\t\t\tcurrLifeline.gridPosition += adjustment;\n\t\t}\n\t}\n\t\n\tevaluatePositions(evaluationStack) {\n\t\t// This sets positions of relatives if they're not already set,\n\t\t// and adds them to the evaluationStack so that their relatives\n\t\t// can also be assigned positions.\n\n\t\t// Get the lifeline on the top of the stack:\n\t\tvar currLifeline = evaluationStack.pop();\n\t\t\n\t\t//console.log(\"Evaluating positions...\");\n\t\t//console.log(currLifeline.person.link);\n\n\t\t// Required information for this algorithm:\n\t\t// - A lifeline, which will be assigned the specified grid position. We\n\t\t// will assign a grid position for each relative of this lifeline, for\n\t\t// every relative that has not already been assigned a position.\n\t\t// - A specified X grid position for that node\n\t\t// - A set of links, indicating which individual's lifelines have been\n\t\t// added for position evaluation already\n\t\t// - A stack of [lifeline, position] pairs to evaluate next.\n\n\t\t//- NOTE: The following algorithm makes no attempt to balance the tree\n\t\t// aesthetically. I will have to see what it looks like before deciding\n\t\t// whether I need a better layout algorithm.\n\n\t\t// Retrieve the grid position of this lifeline:\n\t\tvar currGridPos = currLifeline.gridPosition;\n\t\t\n\t\t// Get relatives:\n\t\tvar person = currLifeline.person;\n\t\tvar mother = person.mother;\n\t\tvar father = person.father;\n\t\tvar children = person.children;\n\t\t\n\t\t// Add mother at X-1 if lifeline is existing and not already specified:\n\t\tif (mother !== undefined) {\n\t\t\tvar motherLifeline = this.link2lifeline[mother.link];\n\t\t\tif (motherLifeline !== undefined) {\n\t\t\t\tvar proposedPos = currGridPos - 1;\n\t\t\t\tif (motherLifeline.gridPosition === null) {\n\t\t\t\t\tmotherLifeline.gridPosition = proposedPos;\n\t\t\t\t\tevaluationStack.push(motherLifeline);\n\t\t\t\t} else if (proposedPos != motherLifeline.gridPosition) {\n\t\t\t\t\tconsole.log(\"Conflicting position for mother.\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Add father at X+1 if lifeline is existing and not already specified:\n\t\tif (father !== undefined) {\n\t\t\tvar fatherLifeline = this.link2lifeline[father.link];\n\t\t\tif (fatherLifeline !== undefined) {\n\t\t\t\tvar proposedPos = currGridPos + 1;\n\t\t\t\tif (fatherLifeline.gridPosition === null) {\n\t\t\t\t\tfatherLifeline.gridPosition = proposedPos;\n\t\t\t\t\tevaluationStack.push(fatherLifeline);\n\t\t\t\t} else if (proposedPos != fatherLifeline.gridPosition) {\n\t\t\t\t\tconsole.log(\"Conflicting position for father.\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Add children at X+1 if this person is the child's mother, and\n\t\t// X-1 otherwise (in which case this person is the child's father):\n\t\tfor (var childIdx = 0; childIdx < children.length; childIdx++) {\n\t\t\tvar currChild = children[childIdx];\n\t\t\tvar currChildLifeline = this.link2lifeline[currChild.link];\n\t\t\tvar childLink = currChild.link;\n\t\t\tif (currChildLifeline !== undefined) {\t\t\t\t\n\t\t\t\tvar proposedPosition = currGridPos - 1;\n\t\t\t\tif (currChild.mother === person) {\n\t\t\t\t\tproposedPosition = currGridPos + 1;\n\t\t\t\t}\n\t\t\t\tif (currChildLifeline.gridPosition === null) {\n\t\t\t\t\tcurrChildLifeline.gridPosition = proposedPosition;\n\t\t\t\t\tevaluationStack.push(currChildLifeline);\n\t\t\t\t} else {\n\t\t\t\t\tif (proposedPos != currChildLifeline.gridPosition) {\n\t\t\t\t\t\tconsole.log(\"Conflicting position for child.\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconsole.log(\"Child position was consistent.\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tassignStartingPositions(focalLifeline) {\n\t\t// While evaluation stack is not empty:\n\t\t// Pop top element and call evaluatePositions(currNode, currPos)\n\n\t\t// Assign the focal point node a position of zero, as it will be the\n\t\t// centre feature for this component:\n\t\tfocalLifeline.gridPosition = 0;\n\n\t\t// Add (focalNode, 0) to the evaluation stack\n\t\t// This stack keeps track of lifelines that have not yet been assigned\n\t\t// positions, along with their proposed starting position:\n\t\tvar evaluationStack = [];\n\t\tevaluationStack.push(focalLifeline);\n\n\t\twhile (evaluationStack.length > 0) {\n\t\t\tthis.evaluatePositions(evaluationStack);\n\t\t}\n\t}\n\n\tgetLifelinesAtPos(currGridPos) {\n\t\tvar lifelinesAtPos = [];\n\t\tfor (var link in this.link2lifeline) {\n\t\t\tvar currLifeline = this.link2lifeline[link];\n\t\t\tvar lifelineGridPos = currLifeline.gridPosition;\n\t\t\tif (currGridPos == lifelineGridPos) {\n\t\t\t\tlifelinesAtPos.push(currLifeline);\n\t\t\t}\n\t\t}\n\t\treturn lifelinesAtPos;\n\t}\n\n\tadjustPositionsForOverlap() {\n\t\t// Move lifeline objects sideways slightly so that none of them\n\t\t// overlap vertically.\n\t\t\n\t\t// Consider each integer grid position currently assigned to lifelines\n\t\t// in this component...\n\t\tvar lowestGridPos = Infinity;\n\t\tvar highestGridPos = -Infinity;\n\t\t\n\t\tfor (var link in this.link2lifeline) {\n\t\t\tvar currLifeline = this.link2lifeline[link];\n\t\t\tvar currGridPos = currLifeline.gridPosition;\n\t\t\tif (currGridPos < lowestGridPos) {\n\t\t\t\tlowestGridPos = currGridPos;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (var link in this.link2lifeline) {\n\t\t\tvar currLifeline = this.link2lifeline[link];\n\t\t\tvar currGridPos = currLifeline.gridPosition;\n\t\t\tif (currGridPos > highestGridPos) {\n\t\t\t\thighestGridPos = currGridPos;\n\t\t\t}\n\t\t}\n\n\t\tvar currGridPos = lowestGridPos;\n\t\twhile (currGridPos <= highestGridPos) {\n\t\t\t// Get all Lifeline objects with this grid position:\n\t\t\tvar currLifelines = this.getLifelinesAtPos(currGridPos);\n\t\t\t\n\t\t\t// Iterate through them, detecting clusters of overlapping\n\t\t\t// lifelines, and \"jittering\" the lifelines in each cluster\n\t\t\t// so that every lifeline has a unique grid position...\n\t\t\t// Details of \"jittering\" for a given cluster: Disperse the given\n\t\t\t// timelines evenly between values -0.4 and +0.4 with respect to\n\t\t\t// the given grid position, starting with the first born\n\t\t\t// individual and ending with the last born individual.\n\n\t\t\t// First, sort by birth date:\n\t\t\tvar lifelinesByBirth = currLifelines.sort(compareBirth);\n\n\t\t\t// Detect clusters:\n\t\t\tvar lifelineClusters = detectClusters(lifelinesByBirth);\n\t\t\t\n\t\t\t// Process each cluster:\n\t\t\tfor (var clusterIdx = 0; clusterIdx < lifelineClusters.length; clusterIdx++) {\n\t\t\t\tvar currCluster = lifelineClusters[clusterIdx];\n\t\t\t\tadjustGridPositions(currCluster, -0.3, 0.3);\n\t\t\t}\n\t\t\t\n\t\t\tcurrGridPos++;\n\t\t}\n\t}\n\n\tgetMinGridPos() {\n\t\tvar minPos = Infinity;\n\t\tfor (var link in this.link2lifeline) {\n\t\t\tvar currLifeline = this.link2lifeline[link];\n\t\t\tif (currLifeline.gridPosition < minPos) {\n\t\t\t\tminPos = currLifeline.gridPosition;\n\t\t\t}\n\t\t}\t\t\n\t\treturn minPos;\n\t}\n\n\tgetMaxGridPos() {\n\t\tvar maxPos = -Infinity;\n\t\tfor (var link in this.link2lifeline) {\n\t\t\tvar currLifeline = this.link2lifeline[link];\n\t\t\tif (currLifeline.gridPosition > maxPos) {\n\t\t\t\tmaxPos = currLifeline.gridPosition;\n\t\t\t}\n\t\t}\n\t\treturn maxPos;\n\t}\n\n\t// Calculate the width of this component in grid units:\n\tgetWidth() {\n\t\tvar maxGridPos = this.getMaxGridPos();\n\t\tvar minGridPos = this.getMinGridPos();\n        return maxGridPos - minGridPos;\n\t}\n\n\t// Assign relative positions to Lifeline objects in this lifeline\n\t// plot component:\n\t// FIXME/NOTE: This is where an algorithm could be specified as an\n\t// argument.\n\tassignRelativePositions() {\n\t\t// Finds coordinates for all individuals in the connected component\n\t\t// relative to a chosen focus node for this component graph.\n\n\t\t// FIXME: This function possibly has too much \"intelligence\" in it.\n\t\t// In the long run, I intend to have different layout algorithms that\n\t\t// perform the task of laying out the Lifeline objects. This will help\n\t\t// in decomposing this logic into smaller parts.\n\t\t//console.log(\"Getting focal person.\");\n\t\t//console.log((new Date()).getTime());\n\t\t\t\t\n\t\tvar focalPerson = this.selectFocalPerson();\n\n\t\t// Get the timeline for that person:\n\t\tvar focalTimeline = this.link2lifeline[focalPerson.link];\n\n\t\tthis.assignStartingPositions(focalTimeline);\n\t\t\n\t\tthis.adjustPositionsForOverlap();\n\t}\n\t\n\tselectFocalPerson() {\n\t\t// Find a chosen node of interest for this connected component (e.g.\n\t\t// the most recent individual who is part of any of the lineages\n\t\t// specified).\n\n\t\t// Retrieve the lineages selected in the host plot:\n\t\tvar lineageLinkSet = new Set(this.hostPlot.lineagesToShow.map(function(lineage) {return lineage.link}));\n\t\t\n\t\t// Consider all individuals in any of those lineages, and select the individual\n\t\t// with the most recent birth date...\n\n\t\t// Filter for representation in those lineages:\n\t\tvar peopleInLineagesLinks = new Set();\n\t\tfor (var personIdx = 0; personIdx < this.peopleLinks.length; personIdx++) {\n\t\t\tvar currPersonLink = this.peopleLinks[personIdx];\n\t\t\tvar currPerson = this.hostPlot.link2person[currPersonLink];\n\t\t\tvar currReigns = currPerson.reigns;\n\n\t\t\tfor (var reignIdx = 0; reignIdx < currReigns.length; reignIdx++) {\n\t\t\t\tvar currReign = currReigns[reignIdx];\n\t\t\t\tvar currLineageLink = currReign.lineage.link;\n\t\t\t\tif (lineageLinkSet.has(currLineageLink)) {\n\t\t\t\t\tpeopleInLineagesLinks.add(currPersonLink);\n\t\t\t\t}\n\t\t\t}\t\t\t\n\t\t}\n\t\t\n\t\tif (Array.from(peopleInLineagesLinks).length == 0) {\n\t\t\t// There were no individuals in the specified lineages =>\n\t\t\t// Consider all individuals:\n\t\t\tpeopleInLineagesLinks = new Set(this.peopleLinks);\n\t\t}\n\n\t\t// Get person objects corresponding to the people in the lineages:\n\t\tvar peopleInLineages = [];\n\t\tvar linksArr = Array.from(peopleInLineagesLinks);\n\t\tfor (var linkIdx = 0; linkIdx < linksArr.length; linkIdx++) {\n\t\t\tvar currPersonLink = linksArr[linkIdx];\n\t\t\tvar currPerson = this.hostPlot.link2person[currPersonLink];\n\t\t\tpeopleInLineages.push(currPerson);\n\t\t}\n\n\t\t// Select the individual with the most recent birth date:\n\t\tvar youngestPerson = null;\n\t\tvar mostRecentBirthDate = -Infinity;\n\t\tfor (var personIdx = 0; personIdx < peopleInLineages.length; personIdx++) {\n\t\t\tvar currPerson = peopleInLineages[personIdx];\n\t\t\tif (currPerson.birth > mostRecentBirthDate) {\n\t\t\t\tmostRecentBirthDate = currPerson.birth;\n\t\t\t\tyoungestPerson = currPerson;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn youngestPerson;\n\t}\n\t\n\tdraw() {\n\t\t// Draw this lifeline plot component on the host svg element...\n\t\t\n\t\tfor (var link in this.link2lifeline) {\n\t\t\tvar currLifeline = this.link2lifeline[link];\n\t\t\tcurrLifeline.draw();\n\t\t}\n\t}\n}\n\n\n// A plot of a set of lifeline bars:\nexport class LifelinePlot {\n\tconstructor(svgTarget, selectedPeople, selectedLineages, link2person) {\n\t\t// - Precondition: The input svg display must be blank when this method is invoked\n\n\t\tthis.startYear = null; // Year corresponding to the start of the plot\n\t\tthis.endYear = null; // Year corresponding to the end of the plot\n\t\tthis.peopleToPlot = selectedPeople;\n\t\tthis.lineagesToShow = selectedLineages;\n\t\tthis.link2person = link2person;\n\t\tthis.plotComponents = [];\n\t\tthis.svgTarget = svgTarget;\n\t\n\t\t // Margin will occupy this much of the svg element:\n\t\tthis.marginFraction = 0.1;\n\t\n\t\tthis.boxWidth = 2; // XXX FIXME. Not sure how/where to specify this and in what units.\n\t}\n\n\tcalculateBoundaryYears() {\n\t\t// Calibrate the canvas start and end year based on the earliest birth\n\t\t// and last death dates:\n\t\tthis.startYear = lineageModule.getFirstBirth(this.peopleToPlot, this.link2person);\n\t\tthis.endYear = lineageModule.getEndDeath(this.peopleToPlot, this.link2person);\n\t\t\n\t\t//console.log(\"TRACE: Years for plot:\");\n\t\t//console.log(this.startYear);\n\t\t//console.log(this.endYear);\n\t}\n\t\n\tgetYearCoord(year) {\n\t\t// FIXME: This has got to be wrong:\n\t\tvar svgHeight = this.svgTarget[0][0].clientHeight;\n\t\t\t\n\t\t// Translate a year to a y position on the plot canvas:\n\t\tvar fractionOfHeight = (year - this.startYear)/(this.endYear - this.startYear);\n\t\tvar yPos = fractionOfHeight*svgHeight; // XXX I think this will work; but PROBLEM: Doesn't consider margins that I might wish to include around the plot itself.\n\t\treturn yPos;\n\t}\n\n\tgetSvgWidth() {\n\t\t// FIXME: This has got to be wrong:\n\t\treturn this.svgTarget[0][0].clientWidth;\n\t}\n\t\n\t// Hacky method to convert x postion as a fraction of width to\n\t// an actual x coordinate on the svg element, taking the margin width\n\t// into consideration:\n\tfraction2position(fractionOfWidth) {\n\t\tvar marginWidth = this.marginFraction * this.getSvgWidth();\n\t\tvar plotWidth = (1 - (this.marginFraction * 2)) * this.getSvgWidth();\n\t\tvar extraDist = fractionOfWidth * plotWidth;\n\t\treturn marginWidth + extraDist;\n\t}\n\t\n\tconvertXpos(gridPos) {\n\t\tvar svgWidth = this.getSvgWidth();\n\t\t\n\t\t// Translate a grid position to an x postion on the plot canvas:\n\t\tvar gridWidth = this.getGridWidth();\n\t\tvar fractionOfWidth = gridPos/gridWidth;\n\t\t\n\t\t// FIXME: Not quite correct but oh well:\n\t\t//console.log(\"X pos:\");\n\t\t//console.log(fractionOfWidth * svgWidth);\n\t\t// Add a margin - temporary hack, for the sake of seeing whether\n\t\t// visualisations are working:\n\t\t\n\t\treturn this.fraction2position(fractionOfWidth);//fractionOfWidth * svgWidth;\n\t}\n\n\tgetMinGridPos() {\n\t\treturn this.plotComponents[0].getMinGridPos();\n\t}\n\n\tgetMaxGridPos() {\n\t\tvar lastComponent = this.plotComponents[this.plotComponents.length - 1];\n\t\treturn lastComponent.getMaxGridPos();\n\t}\n\n\tgetGridWidth() {\n\t\treturn this.getMaxGridPos() - this.getMinGridPos();\n\t}\n\n\tconvertYpos(yPos) {\n\t\t// XXX FIXME: Adjust to include margin:\n\t\treturn this.getYearCoord(yPos);\n\t}\n\n\tdisplayLifelines() {\n\t\t// Overview:\n\t\t/*\n\t\t-- Displays a given ancestry graph consisting of\n\t\t1) A set of individuals with birth and death dates\n\t\t2) A set of zero or more royalty titles with date ranges and corresponding\n\t\tindividuals specified (it may be important for this to be indexed for\n\t\tefficient retrieval)\n\t\t3) A set of individual->individual edges indicating parent-child\n\t\trelationships, labelled as mother or father. NOTE: I need this data\n\t\tstructure in a form that is computationally efficient to retrieve edges\n\t\tfrom. It might be necessary to have a sparse 2D matrix, but this would be\n\t\tlarge. -> Update: Not sure about my thinking here; I think it should be ok\n\t\tjust having a dictionary indexed by person links, and by then looking in\n\t\tthe mother/father/child fields for the given person of interest.\n\t\t--- Assigns x positions to all selected individuals (call function that\n\t\tdoes this)\n\t\t--- Draws rectangles and lines connecting them to represent those\n\t\tindividuals and parent-child relationships\n\t\t--- Colours regions within rectangles to represent the specified titles\n\t\t*/\n\n\t\tvar layoutAlgorithm = null; // XXX EDIT THIS\n\n\t\t// Calculate the start and end year for the plot:\n\t\tthis.calculateBoundaryYears();\n\n\t\t// Determine connected components from the specified people to plot:\n\t\tvar connectedComponents = getConnectedComponents(this.peopleToPlot, this.link2person);\n\n\t\t// Produce plot components corresponding to the connected components:\n\t\tfor (var compIdx = 0; compIdx < connectedComponents.length; compIdx++) {\n\t\t\tvar currComponent = connectedComponents[compIdx];\n\t\t\tvar currPlotComponent = new LifelinePlotComponent(currComponent.nodes, this);\n\n\t\t\t// Generate lifeline objects for each of the people in the current\n\t\t\t// plot component. Here, also Generate parent/child links:\n\t\t\tcurrPlotComponent.generateLifelines();\n\t\t\tcurrPlotComponent.generateBirthlines();\n\t\t\t\n\t\t\tcurrPlotComponent.assignRelativePositions();\n\n\t\t\tthis.plotComponents.push(currPlotComponent);\n\t\t}\n\n\t\tconsole.log(this);\n\n\t\t// Adjust lifeline grid positions again, to add cumulative width to\n\t\t// components two onwards, thus separatting them horizontally...\n\n\t\t// Need to shift all components by the negative or postive overhang\n\t\t// amount obtained for the left-most component:\n\t\tvar leftMostComponent = this.plotComponents[0];\n\t\tvar leftShift = -leftMostComponent.getMinGridPos();\n\t\t\n\t\t// Gap size to add between components:\n\t\tvar componentGap = 1;\n\t\t\n\t\tvar cumulativeWidth = 0;\n\t\tfor (var compIdx = 0; compIdx < this.plotComponents.length; compIdx++) {\n\t\t\tvar currComponent = this.plotComponents[compIdx];\n\t\t\t\n\t\t\tvar currComponentWidth = currComponent.getWidth();\n\t\t\t\n\t\t\tcurrComponent.adjustOverallPosition(cumulativeWidth + leftShift);\n\t\t\t\t\t\t\n\t\t\tcumulativeWidth = cumulativeWidth + currComponentWidth + componentGap;\n\t\t}\n\n\t\tconsole.log(\"TRACE: Plot after adjusting widths:\");\n\t\tconsole.log(this);\n\t\t\n\t\t// Render each of the components on the svg element:\n\t\tfor (var compIdx = 0; compIdx < this.plotComponents.length; compIdx++) {\n\t\t\tvar currComponent = this.plotComponents[compIdx];\n\t\t\tcurrComponent.draw();\n\t\t}\t\t\n\n\t\t// XXX CONTINUE HERE NEXT: I have starting grid positions now. Now, I am ready to implement\n\t\t// drawing of lifelines and birthlines on the svg element.\n\t\t// XXX ONCE I'VE IMPLEMENTED THE RELATIVE POSITION DETERMINATION ALGORITHM, THEN IMPLEMENT THIS PART.\n\t\t// -- Render boxes and lines for the lifelines as determined by their relative positions within the connected components and the connected component relative positions and sizes. NOTE: This will involve calculating the absolute positions of the lifelines and parent-child lines. These calculations are specified by the relative positions (which are known by the lifeline objects), the connected component widths (which those objects can compute based on their constituent lifeline objects), the connected component relative positions (which can be assigned using some trivial algorithm and which has no real importance), and target svg canvas size, and the margin size (which is a default parameter of the lifelineplot class). NOTE: I need to decide which object(s) do the calculations of exact object positions. Perhaps the LifelinePlot object takes care of this? Also, I'm pretty sure the individual lifeline and parentChildLink objects should not know about their absolute positions; otherwise we would be duplicating data. However, they have links to their actual rectangle and line objects, so they can retrieve/set those values if needed.\n\n\t\t//\tcurrComponentStartPos = 0\n\t\t//\tfor component in components:\n\t\t//\t\tcomponent.adjustForComponentStartPos()\n\t\t//\t\tcompoment.calculateTotalWidth()\n\t\t//\t\tcomponent.setAbsolutePositions() // add width to start position, plus a gap, and convert to actual canvas x positions\n\n\t\t//displayBoxes(lifelines)\n\t}\n}\n\n\n// Lifeline class - a rectangular representation of a person's lifespan,\n// within a lifeline plot:\nexport class Lifeline {\n\tconstructor(person, hostComponent) {\n\t\tthis.person = person;\n\t\tthis.hostComponent = hostComponent;\n\t\n\t\t// Parent/Child birth lines for this individual (as a child):\n\t\tthis.motherBirthline = null;\n\t\tthis.fatherBirthline = null;\n\t\n\t\tthis.gridPosition = null; // A grid position on the plot.\n\n\t\tthis.svgRectangle = null;\n\t\n\t\t// Bars indicating periods as a reigning monarch:\n\t\tthis.reignBars = [];\n\t\n\t\t// XXX Should the lifeline have a set of links to child lifelines? Should it have a mother and father link?\n\t}\n\n\tgetXstart() {\n\t\treturn this.hostComponent.hostPlot.convertXpos(this.gridPosition);\n\t}\n\t\n\tgetYstart() {\n\t\treturn this.hostComponent.hostPlot.convertYpos(this.person.birth);\n\t}\n\n\tgetYend() {\n\t\treturn this.hostComponent.hostPlot.convertYpos(this.person.getDeath());\n\t}\n\t\n\tdraw() {\n\t\tvar xStart = this.getXstart();\n\t\tvar yStart = this.getYstart();\n\t\tvar yEnd = this.getYend();\n\t\t\n\t\t// Generate the actual svg rectangle:\n\t\tvar boxWidth = this.hostComponent.hostPlot.boxWidth;\n\t\tthis.svgRectangle = this.hostComponent.hostPlot.svgTarget.append(\"rect\")\n\t\t\t\t\t\t\t   \t\t\t\t\t   .attr(\"x\", xStart)\n\t\t\t\t\t\t\t\t\t\t\t\t   .attr(\"y\", yStart)\n\t\t\t\t\t\t\t\t\t\t\t\t   .attr(\"width\", boxWidth)\n\t\t\t\t\t\t\t\t\t\t\t\t   .attr(\"height\", yEnd-yStart);\n\n\t\t// FIXME: A bit hacky: Add a click listener to the wikipedia page:\n\t\tvar lifeline = this;\n\t\tvar callback = function() {console.log(lifeline); lifeline.select(1)}\n\t\tthis.svgRectangle[0][0].addEventListener(\"click\", callback);//person.select\n\n\t\t// Draw the mother and father birthlines, if they exist:\n\t\tif (this.motherBirthline !== null) {\n\t\t\tthis.motherBirthline.draw();\n\t\t}\n\n\t\tif (this.fatherBirthline !== null) {\n\t\t\tthis.fatherBirthline.draw();\n\t\t}\n\t\t\n\t\t// Draw reigns for this lifeline:\n\t\tthis.drawReigns();\n\t}\n\n\tdrawReigns() {\n\t\t// FIXME: Perhaps need to think about how to do this a bit more.\n\t\tvar lineagesToShowLinks = new Set(this.hostComponent.hostPlot.lineagesToShow.map(function(x) {return x.link}));\n\n\t\t// Draw each reign of this individual for any of those lineages...\n\t\tfor (var reignIdx = 0; reignIdx < this.person.reigns.length; reignIdx++) {\n\t\t\tvar currReign = this.person.reigns[reignIdx];\n\t\t\tvar currLineageLink = currReign.lineage.link;\n\t\t\tif (lineagesToShowLinks.has(currLineageLink)) {\n\t\t\t\t// We should draw this Reign object. Currently, just draw a\n\t\t\t\t// rectangle. FIXME: Revisit this:\n\t\t\t\tvar yStart = this.hostComponent.hostPlot.convertYpos(currReign.start);\n\t\t\t\tvar yEnd = this.hostComponent.hostPlot.convertYpos(currReign.end);\n\t\t\t\tvar xStart = this.getXstart();\n\t\t\t\tvar boxWidth = this.hostComponent.hostPlot.boxWidth;\n\t\t\t\tvar reignRectangle = this.hostComponent.hostPlot.svgTarget.append(\"rect\")\n\t\t\t\t\t\t\t\t   \t\t\t\t\t   .attr(\"x\", xStart)\n\t\t\t\t\t\t\t\t\t\t\t\t\t   .attr(\"y\", yStart)\n\t\t\t\t\t\t\t\t\t\t\t\t\t   .attr(\"width\", boxWidth)\n\t\t\t\t\t\t\t\t\t\t\t\t\t   .attr(\"height\", yEnd-yStart)\n\t\t\t\t\t\t\t\t\t\t\t\t\t   .attr(\"fill\", \"yellow\")\n\t\t\t\t\t\t\t\t\t\t\t\t\t   .attr(\"stroke\", \"yellow\");\n\t\t\t\tthis.reignBars.push(reignRectangle);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tselect(depth) {\n\t\tvar person = this.person;\n\t\tvar currLink = \"https://en.wikipedia.org\".concat(person.link);\n\n\t\t// Depth of 1 indicates direct selection => clear everything first:\n\t\t// FIXME: This seems hacky - I'm altering all rectangles in the svg.\n\t\tvar rectangles = this.hostComponent.hostPlot.svgTarget.selectAll(\"rect\");\n\n\t\t// FIXME: Need to decide how/where to specify starting colour properly\n\t\t// for resetting the colour:\n\t\t//var startingColour = \"black\";\n\t\t//rectangles.attr(\"stroke\", startingColour).attr(\"fill\", startingColour);\n\n\t\tdisplaySelected(this.svgRectangle, depth);\n\t\t\n\t\t// \"Select\" the mother and father lifelines recursively, if selection\n\t\t// \"depth\" is not too high:\n\t\tif (depth <= 2) {\n\t\t\tif (this.motherBirthline !== undefined && this.motherBirthline !== null) {\n\t\t\t\tvar parentLifeline = this.motherBirthline.parentLifeline;\n\t\t\t\tparentLifeline.select(depth+1);\n\t\t\t}\n\t\t\tif (this.fatherBirthline !== undefined && this.fatherBirthline !== null) {\n\t\t\t\tvar parentLifeline = this.fatherBirthline.parentLifeline;\n\t\t\t\tparentLifeline.select(depth+1);\n\t\t\t}\n\t\t}\n\n\t\tdocument.getElementsByTagName(\"iframe\")[0].src=currLink;\n\t}\n}\n\n\n// XXXYYY INTRODUCE A REIGN-BAR CLASS, AND MOVE CODE FOR DRAWING REIGNS IN IT'S RENDER FUNCTION.\n\n\n// FIXME: Code for indicating selection of a rectangle with a specified\n// intensity level. Should replace this with a CSS class name approach,\n// once I can get that working for SVG elements:\nfunction displaySelected(svgRectangle, intensityLevel) {\n\t// FIXME: Really nasty hack; need a better way to do this:\n\tvar colour1 = \"#47EDFF\";\n\tvar colour2 = \"#36B8C7\";\n\tvar colour3 = \"#247B85\";\n\tvar selectedColour = colour1;\n\tif (intensityLevel == 2) {\n\t\tselectedColour = colour2;\n\t} else if (intensityLevel == 3) {\n\t\tselectedColour = colour3;\n\t} else if (intensityLevel > 3) {\n\t\tselectedColour = \"black\";\n\t}\n\tsvgRectangle.attr(\"stroke\", selectedColour).attr(\"fill\", selectedColour);\n}\n\n\n// Birthline class: A line representing the relationship between this parent\n// and this child at the year of birth:\nexport class Birthline {\n\tconstructor(childLifeline, parentLifeline) {\n\t\tthis.childLifeline = childLifeline;\n\t\tthis.parentLifeline = parentLifeline;\n\t\tthis.svgLine = null;\n\t}\n\n\tdraw() {\n\t\tvar birthDate = this.childLifeline.person.birth;\n\t\t// FIXME: Particularly nasty code:\n\t\tvar yPos = this.childLifeline.hostComponent.hostPlot.convertYpos(birthDate);\n\t\tif (this.childLifeline !== undefined && this.parentLifeline !== undefined) {\n\t\t\tvar childX = this.childLifeline.getXstart();\n\t\t\tvar parentX = this.parentLifeline.getXstart();\n\t\t\tvar xStart = childX;\n\t\t\tvar xEnd = parentX;\n\t\t\tif (childX > parentX) {\n\t\t\t\txStart = parentX;\n\t\t\t\txEnd = childX;\n\t\t\t}\n\t\t\t\n\t\t\t// FIXME: I want to draw a line but I don't know how :-(\n\t\t\t// FIXME: I want this to be semi-transparent. This works, but not\n\t\t\t// sure if this is the right way (with css etc.):\n\t\t\tthis.svgLine = this.childLifeline.hostComponent.hostPlot.svgTarget.append(\"rect\")\n\t\t\t\t\t\t\t\t\t   \t\t\t\t\t   .attr(\"x\", xStart)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   .attr(\"y\", yPos)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   .attr(\"width\", xEnd-xStart)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   .attr(\"height\", 1)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   .attr(\"fill-opacity\", 0.1);\n\t\t}\n\t}\n}\n\n\n// Connected component class:\nclass ConnectedComponent {\n\tconstructor() {\n\t\tthis.nodes = [];\n\t}\n\n\taddNode(node) {\n\t\tthis.nodes.push(node);\n\t}\n}\n\n\n// This is getting a bit hacky:\nexport function getPersonName2Link(link2person) {\n\t// Extract person. NOTE: I'm assuming the names are unique (as are the\n\t// links):\n\tvar name2link = {};\n\tfor (var link in link2person) {\n\t\tvar name = link2person[link].name;\n\t\tname2link[name] = link;\n\t}\n\n\treturn name2link;\n}\n\n\n// This is getting a bit hacky:\nexport function getLineageName2Link(link2lineage) {\n\t// PROBLEM/FIXME: Lineage links are used here; I want to have the names\n\t// instead:\n\tvar name2link = {};\n\tfor (var link in link2lineage) {\n\t\tvar name = link2lineage[link].name;\n\t\tname2link[name] = link;\n\t}\n\n\treturn name2link;\n}\n\n\n// Enters the person and lineage search data into the interface elements:\nexport function populateInterface(personNames, lineageNames) {\n\t// Javascript UI code; don't yet understand this 100% but it's needed to\n\t// get my autocomplete boxes working:\n\t$(function() {\n\t\t$( \"#personSelection\" ).autocomplete({\n\t\t\tsource: personNames\n\t\t});\n\t});\n\t\n\t$(function() {\n\t\t$( \"#lineageSelection\" ).autocomplete({\n\t\t\tsource: lineageNames\n\t\t});\n\t});\n}\n\n\nfunction breadthFirstSearch(rootPerson, peopleAdded, personFilter, link2person) {\n\t// NOTE: personFilter is a set of person links denoting people that can\n\t// be included; all others should be ignored.\n\n\tvar connectedComponent = new ConnectedComponent();\n\t\n\tvar stack = [];\n\tstack.push(rootPerson);\n\n\t//console.log(\"TRACE: Performing breadthFirstSearch from this root person:\");\n\t//console.log(rootPerson);\n\t\n\twhile (stack.length > 0) {\n\t\tvar currPerson = stack.pop();\n\t\t//console.log(\"currPerson:\");\n\t\t//console.log(currPerson);\n\n\t\t//console.log(\"personFilter:\");\n\t\t//console.log(personFilter);\n\t\t//console.log(personFilter.has(currPerson));\n\n\t\tif (personFilter.has(currPerson)) {\n\t\t\t//console.log(\"Branching from current person...\");\n\t\t\t//console.log(\"TRACE: Connected component:\");\n\t\t\t//console.log(connectedComponent);\n\n\t\t\t// The person is allowed to be added and branched from.\n\t\t\tconnectedComponent.addNode(currPerson);\n\n\t\t\t//console.log(\"TRACE AGAIN: Connected component:\");\n\t\t\t//console.log(connectedComponent);\n\t\t\t\n\t\t\tpeopleAdded.add(currPerson);\n \t\t\t//console.log(\"TRACE XXX: peopleAdded:\");\n\t\t\t//console.log(peopleAdded);\n\n\t\t\tvar actualPersonObj = link2person[currPerson];\n\n\t\t\tvar relatives = actualPersonObj.getRelatives();\n\t\t\tvar nRelatives = relatives.length;\n\n\t\t\tfor (var relativeIdx = 0; relativeIdx < nRelatives; relativeIdx++) {\n\t\t\t\tvar currRelativeObj = relatives[relativeIdx];\n\t\t\t\t// Only add item to the stack if it's in the filtered set of\n\t\t\t\t// people and they haven't already been added to a\n\t\t\t\t// connected component:\n\t\t\t\tif (personFilter.has(currRelativeObj.link) && !(peopleAdded.has(currRelativeObj.link))) {\n\t\t\t\t\tstack.push(currRelativeObj.link);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//console.log(\"TRACE: Stack after adding relatives:\");\n\t\t\t//console.log(stack);\n\t\t}\n\t}\n\t\n\treturn connectedComponent;\n}\n\n\n// FIXME: I have made a mess in these functions in terms of what is a person link\n// and which variables are actual person objects. Also, the naming of variables is ambiguous.\n\nfunction getConnectedComponents(selectedPeople, link2person) {\n\t//console.log(\"GETTING CONNECTED COMPONENTS...\");\n\t// Perform breadth-first search to find the connected components...\n\tvar componentGraphs = [];\n\n\tvar peopleAdded = new Set();\n\n\tvar selectedPeopleArr = Array.from(selectedPeople);\n\t\n\t//console.log(\"Selected people:\");\n\t//console.log(selectedPeopleArr);\n\t\n\tvar nPeople = selectedPeopleArr.length;\n\tfor (var personIdx = 0; personIdx < nPeople; personIdx++) {\n\t\tvar currPerson = selectedPeopleArr[personIdx];\n\t\t\n\t\tif (!(peopleAdded.has(currPerson))) {\n\t\t\t// The person has not been added to a connected component yet\n\t\t\t// => perform (filtered) breadth-first search from it, keeping track\n\t\t\t// of added nodes...\n\t\t\t// NOTE: Only the specified \"selected people\" will be included in\n\t\t\t// the breadth-first search:\n\t\t\t//console.log(\"TRACE: peopleAdded:\");\n\t\t\t//console.log(peopleAdded);\n\t\t\tvar currComponent = breadthFirstSearch(currPerson, peopleAdded, selectedPeople, link2person);\n\t\t\tcomponentGraphs.push(currComponent);\n\t\t}\n\t}\n\n\t//console.log(\"Component graphs:\");\n\t//console.log(componentGraphs);\n\t//console.log(\"Finished getting connected components.\");\n\n\t// Return components (as an array of TimelineConnComp objects):\n\treturn componentGraphs;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/lifelines.js\n **/"],"sourceRoot":""}